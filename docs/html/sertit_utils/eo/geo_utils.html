<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>sertit_utils.eo.geo_utils API documentation</title>
<meta name="description" content="Geo tools" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sertit_utils.eo.geo_utils</code></h1>
</header>
<section id="section-intro">
<p>Geo tools</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Geo tools &#34;&#34;&#34;
import logging
import os
from typing import Union
import numpy as np
import geopandas as gpd
from shapely import wkt
from shapely.geometry import MultiPolygon, Polygon, box
from rasterio import crs
from sertit_utils.core.log_utils import SU_NAME

LOGGER = logging.getLogger(SU_NAME)

WGS84 = &#34;EPSG:4326&#34;


def corresponding_utm_projection(lon: float, lat: float) -&gt; str:
    &#34;&#34;&#34;
    Find the EPSG code of the UTM projection from a lon/lat in WGS84.

    ```python
    corresponding_utm_projection(lon=48.6, lat=7.8)  # Strasbourg
    # &gt;&gt; &#34;EPSG:32632&#34;
    ```

    Args:
        lon (float): Longitude (WGS84)
        lat (float): Latitude (WGS84)

    Returns:
        str: EPSG string

    &#34;&#34;&#34;
    # EPSG code begins with 32
    # Then 6 if north, 7 if south -&gt; (np.sign(lat) + 1) / 2 * 100 == 1 if lat &gt; 0 (north), 0 if lat &lt; 0 (south)
    # Then EPSG code with usual formula np.floor((180 + lon) / 6) + 1)
    epsg = int(32700 - (np.sign(lat) + 1) / 2 * 100 + np.floor((180 + lon) / 6) + 1)
    return &#34;EPSG:{}&#34;.format(epsg)


def from_polygon_to_bounds(polygon: Union[Polygon, MultiPolygon]) -&gt; (float, float, float, float):
    &#34;&#34;&#34;
    Convert a `shapely.polygon` to its bounds, sorted as `left, bottom, right, top`.

    Args:
        polygon (MultiPolygon): polygon to convert

    Returns:
        (float, float, float, float): left, bottom, right, top
    &#34;&#34;&#34;
    left = polygon.bounds[0]  # xmin
    bottom = polygon.bounds[1]  # ymin
    right = polygon.bounds[2]  # xmax
    top = polygon.bounds[3]  # ymax

    assert left &lt; right
    assert bottom &lt; top

    return left, bottom, right, top


def from_bounds_to_polygon(left: float, bottom: float, right: float, top: float) -&gt; Polygon:
    &#34;&#34;&#34;
    Convert the bounds to a `shapely.polygon`.

    Args:
        left (float): Left coordinates
        bottom (float): Bottom coordinates
        right (float): Right coordinates
        top (float): Top coordinates

    Returns:
        Polygon: Polygon corresponding to the bounds

    &#34;&#34;&#34;
    return box(min(left, right), min(top, bottom), max(left, right), max(top, bottom))


def get_geodf(geometry: Union[Polygon, list, gpd.GeoSeries], geom_crs: Union[crs.CRS, str]) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get a GeoDataFrame from a geometry and a crs
    Args:
        geometry (Union[Polygon, list]): List of Polygons, or Polygon or bounds
        geom_crs (Union[crs.CRS, str]): CRS of the polygon

    Returns:
        gpd.GeoDataFrame: Geometry as a geodataframe
    &#34;&#34;&#34;
    if isinstance(geometry, list):
        if isinstance(geometry[0], Polygon):
            pass
        else:
            try:
                geometry = [from_bounds_to_polygon(*geometry)]
            except TypeError as ex:
                raise TypeError(&#34;Give the extent as &#39;left&#39;, &#39;bottom&#39;, &#39;right&#39;, and &#39;top&#39;&#34;) from ex
    elif isinstance(geometry, Polygon):
        geometry = [geometry]
    elif isinstance(geometry, gpd.GeoSeries):
        geometry = [from_bounds_to_polygon(*geometry.values)]
    else:
        raise TypeError(&#34;geometry should be a list or a Polygon.&#34;)

    return gpd.GeoDataFrame(geometry=geometry, crs=geom_crs)


def set_kml_driver():
    &#34;&#34;&#34;
    Set KML driver for Fiona data (use it at your own risks !)
    &#34;&#34;&#34;
    drivers = gpd.io.file.fiona.drvsupport.supported_drivers
    if &#39;LIBKML&#39; not in drivers:
        drivers[&#39;LIBKML&#39;] = &#39;rw&#39;
    if &#39;KML&#39; not in drivers:  # Just in case
        drivers[&#39;KML&#39;] = &#39;rw&#39;


def get_aoi_wkt(aoi_path, as_str=True) -&gt; Union[str, Polygon]:
    &#34;&#34;&#34;
    Get AOI formatted as a WKT from files that can be read by Fiona (like shapefiles, ...)
    or directly from a WKT file. The use of KML has been forced (use it at your own risks !).

    See: https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open

    It is assessed that:

    - only **one** polygon composes the AOI (as only the first one is read)
    - it should be specified in lat/lon (WGS84) if a WKT file is provided

    Args:
        aoi_path (str): Absolute or relative path to an AOI.
            Its format should be WKT or any format read by Fiona, like shapefiles.
        as_str (bool): If True, return WKT as a str, otherwise as a shapely geometry

    Returns:
        Union[str, Polygon]: AOI formatted as a WKT stored in lat/lon
    &#34;&#34;&#34;
    if not os.path.isfile(aoi_path):
        raise FileNotFoundError(&#34;AOI file {} does not exist.&#34;.format(aoi_path))

    if aoi_path.endswith(&#39;.wkt&#39;):
        try:
            with open(aoi_path, &#39;r&#39;) as aoi_f:
                aoi = wkt.load(aoi_f)
        except Exception as ex:
            raise Exception(&#39;AOI WKT cannot be read&#39;) from ex
    else:
        try:
            if aoi_path.endswith(&#34;.kml&#34;):
                set_kml_driver()

            # Open file
            aoi_file = gpd.read_file(aoi_path)

            # Check if a conversion to lon/lat is needed
            if aoi_file.crs.srs != WGS84:
                aoi_file = aoi_file.to_crs(WGS84)

            # Get envelope polygon
            geom = aoi_file[&#39;geometry&#39;]
            if len(geom) &gt; 1:
                LOGGER.warning(&#34;Your AOI contains several polygons. Only the first will be treated !&#34;)
            polygon = geom[0].convex_hull

            # Convert to WKT
            aoi = wkt.loads(str(polygon))

        except Exception as ex:
            raise Exception(&#39;AOI cannot be read by Fiona&#39;) from ex

    # Convert to string if needed
    if as_str:
        aoi = wkt.dumps(aoi)

    LOGGER.debug(&#39;Specified AOI in WKT: %s&#39;, aoi)
    return aoi</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sertit_utils.eo.geo_utils.corresponding_utm_projection"><code class="name flex">
<span>def <span class="ident">corresponding_utm_projection</span></span>(<span>lon: float, lat: float) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Find the EPSG code of the UTM projection from a lon/lat in WGS84.</p>
<pre><code class="language-python">corresponding_utm_projection(lon=48.6, lat=7.8)  # Strasbourg
# &gt;&gt; &quot;EPSG:32632&quot;
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitude (WGS84)</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>Latitude (WGS84)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>EPSG string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corresponding_utm_projection(lon: float, lat: float) -&gt; str:
    &#34;&#34;&#34;
    Find the EPSG code of the UTM projection from a lon/lat in WGS84.

    ```python
    corresponding_utm_projection(lon=48.6, lat=7.8)  # Strasbourg
    # &gt;&gt; &#34;EPSG:32632&#34;
    ```

    Args:
        lon (float): Longitude (WGS84)
        lat (float): Latitude (WGS84)

    Returns:
        str: EPSG string

    &#34;&#34;&#34;
    # EPSG code begins with 32
    # Then 6 if north, 7 if south -&gt; (np.sign(lat) + 1) / 2 * 100 == 1 if lat &gt; 0 (north), 0 if lat &lt; 0 (south)
    # Then EPSG code with usual formula np.floor((180 + lon) / 6) + 1)
    epsg = int(32700 - (np.sign(lat) + 1) / 2 * 100 + np.floor((180 + lon) / 6) + 1)
    return &#34;EPSG:{}&#34;.format(epsg)</code></pre>
</details>
</dd>
<dt id="sertit_utils.eo.geo_utils.from_bounds_to_polygon"><code class="name flex">
<span>def <span class="ident">from_bounds_to_polygon</span></span>(<span>left: float, bottom: float, right: float, top: float) ‑> shapely.geometry.polygon.Polygon</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the bounds to a <code>shapely.polygon</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>left</code></strong> :&ensp;<code>float</code></dt>
<dd>Left coordinates</dd>
<dt><strong><code>bottom</code></strong> :&ensp;<code>float</code></dt>
<dd>Bottom coordinates</dd>
<dt><strong><code>right</code></strong> :&ensp;<code>float</code></dt>
<dd>Right coordinates</dd>
<dt><strong><code>top</code></strong> :&ensp;<code>float</code></dt>
<dd>Top coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Polygon</code></dt>
<dd>Polygon corresponding to the bounds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_bounds_to_polygon(left: float, bottom: float, right: float, top: float) -&gt; Polygon:
    &#34;&#34;&#34;
    Convert the bounds to a `shapely.polygon`.

    Args:
        left (float): Left coordinates
        bottom (float): Bottom coordinates
        right (float): Right coordinates
        top (float): Top coordinates

    Returns:
        Polygon: Polygon corresponding to the bounds

    &#34;&#34;&#34;
    return box(min(left, right), min(top, bottom), max(left, right), max(top, bottom))</code></pre>
</details>
</dd>
<dt id="sertit_utils.eo.geo_utils.from_polygon_to_bounds"><code class="name flex">
<span>def <span class="ident">from_polygon_to_bounds</span></span>(<span>polygon: Union[shapely.geometry.polygon.Polygon, shapely.geometry.multipolygon.MultiPolygon]) ‑> (<class 'float'>, <class 'float'>, <class 'float'>, <class 'float'>)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a <code>shapely.polygon</code> to its bounds, sorted as <code>left, bottom, right, top</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polygon</code></strong> :&ensp;<code>MultiPolygon</code></dt>
<dd>polygon to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(float, float, float, float): left, bottom, right, top</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_polygon_to_bounds(polygon: Union[Polygon, MultiPolygon]) -&gt; (float, float, float, float):
    &#34;&#34;&#34;
    Convert a `shapely.polygon` to its bounds, sorted as `left, bottom, right, top`.

    Args:
        polygon (MultiPolygon): polygon to convert

    Returns:
        (float, float, float, float): left, bottom, right, top
    &#34;&#34;&#34;
    left = polygon.bounds[0]  # xmin
    bottom = polygon.bounds[1]  # ymin
    right = polygon.bounds[2]  # xmax
    top = polygon.bounds[3]  # ymax

    assert left &lt; right
    assert bottom &lt; top

    return left, bottom, right, top</code></pre>
</details>
</dd>
<dt id="sertit_utils.eo.geo_utils.get_aoi_wkt"><code class="name flex">
<span>def <span class="ident">get_aoi_wkt</span></span>(<span>aoi_path, as_str=True) ‑> Union[str, shapely.geometry.polygon.Polygon]</span>
</code></dt>
<dd>
<div class="desc"><p>Get AOI formatted as a WKT from files that can be read by Fiona (like shapefiles, &hellip;)
or directly from a WKT file. The use of KML has been forced (use it at your own risks !).</p>
<p>See: <a href="https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open">https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open</a></p>
<p>It is assessed that:</p>
<ul>
<li>only <strong>one</strong> polygon composes the AOI (as only the first one is read)</li>
<li>it should be specified in lat/lon (WGS84) if a WKT file is provided</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>aoi_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Absolute or relative path to an AOI.
Its format should be WKT or any format read by Fiona, like shapefiles.</dd>
<dt><strong><code>as_str</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, return WKT as a str, otherwise as a shapely geometry</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, Polygon]</code></dt>
<dd>AOI formatted as a WKT stored in lat/lon</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_aoi_wkt(aoi_path, as_str=True) -&gt; Union[str, Polygon]:
    &#34;&#34;&#34;
    Get AOI formatted as a WKT from files that can be read by Fiona (like shapefiles, ...)
    or directly from a WKT file. The use of KML has been forced (use it at your own risks !).

    See: https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open

    It is assessed that:

    - only **one** polygon composes the AOI (as only the first one is read)
    - it should be specified in lat/lon (WGS84) if a WKT file is provided

    Args:
        aoi_path (str): Absolute or relative path to an AOI.
            Its format should be WKT or any format read by Fiona, like shapefiles.
        as_str (bool): If True, return WKT as a str, otherwise as a shapely geometry

    Returns:
        Union[str, Polygon]: AOI formatted as a WKT stored in lat/lon
    &#34;&#34;&#34;
    if not os.path.isfile(aoi_path):
        raise FileNotFoundError(&#34;AOI file {} does not exist.&#34;.format(aoi_path))

    if aoi_path.endswith(&#39;.wkt&#39;):
        try:
            with open(aoi_path, &#39;r&#39;) as aoi_f:
                aoi = wkt.load(aoi_f)
        except Exception as ex:
            raise Exception(&#39;AOI WKT cannot be read&#39;) from ex
    else:
        try:
            if aoi_path.endswith(&#34;.kml&#34;):
                set_kml_driver()

            # Open file
            aoi_file = gpd.read_file(aoi_path)

            # Check if a conversion to lon/lat is needed
            if aoi_file.crs.srs != WGS84:
                aoi_file = aoi_file.to_crs(WGS84)

            # Get envelope polygon
            geom = aoi_file[&#39;geometry&#39;]
            if len(geom) &gt; 1:
                LOGGER.warning(&#34;Your AOI contains several polygons. Only the first will be treated !&#34;)
            polygon = geom[0].convex_hull

            # Convert to WKT
            aoi = wkt.loads(str(polygon))

        except Exception as ex:
            raise Exception(&#39;AOI cannot be read by Fiona&#39;) from ex

    # Convert to string if needed
    if as_str:
        aoi = wkt.dumps(aoi)

    LOGGER.debug(&#39;Specified AOI in WKT: %s&#39;, aoi)
    return aoi</code></pre>
</details>
</dd>
<dt id="sertit_utils.eo.geo_utils.get_geodf"><code class="name flex">
<span>def <span class="ident">get_geodf</span></span>(<span>geometry: Union[shapely.geometry.polygon.Polygon, list, geopandas.geoseries.GeoSeries], geom_crs: Union[rasterio.crs.CRS, str]) ‑> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Get a GeoDataFrame from a geometry and a crs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong> :&ensp;<code>Union[Polygon, list]</code></dt>
<dd>List of Polygons, or Polygon or bounds</dd>
<dt><strong><code>geom_crs</code></strong> :&ensp;<code>Union[crs.CRS, str]</code></dt>
<dd>CRS of the polygon</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Geometry as a geodataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_geodf(geometry: Union[Polygon, list, gpd.GeoSeries], geom_crs: Union[crs.CRS, str]) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get a GeoDataFrame from a geometry and a crs
    Args:
        geometry (Union[Polygon, list]): List of Polygons, or Polygon or bounds
        geom_crs (Union[crs.CRS, str]): CRS of the polygon

    Returns:
        gpd.GeoDataFrame: Geometry as a geodataframe
    &#34;&#34;&#34;
    if isinstance(geometry, list):
        if isinstance(geometry[0], Polygon):
            pass
        else:
            try:
                geometry = [from_bounds_to_polygon(*geometry)]
            except TypeError as ex:
                raise TypeError(&#34;Give the extent as &#39;left&#39;, &#39;bottom&#39;, &#39;right&#39;, and &#39;top&#39;&#34;) from ex
    elif isinstance(geometry, Polygon):
        geometry = [geometry]
    elif isinstance(geometry, gpd.GeoSeries):
        geometry = [from_bounds_to_polygon(*geometry.values)]
    else:
        raise TypeError(&#34;geometry should be a list or a Polygon.&#34;)

    return gpd.GeoDataFrame(geometry=geometry, crs=geom_crs)</code></pre>
</details>
</dd>
<dt id="sertit_utils.eo.geo_utils.set_kml_driver"><code class="name flex">
<span>def <span class="ident">set_kml_driver</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set KML driver for Fiona data (use it at your own risks !)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_kml_driver():
    &#34;&#34;&#34;
    Set KML driver for Fiona data (use it at your own risks !)
    &#34;&#34;&#34;
    drivers = gpd.io.file.fiona.drvsupport.supported_drivers
    if &#39;LIBKML&#39; not in drivers:
        drivers[&#39;LIBKML&#39;] = &#39;rw&#39;
    if &#39;KML&#39; not in drivers:  # Just in case
        drivers[&#39;KML&#39;] = &#39;rw&#39;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sertit_utils.eo" href="index.html">sertit_utils.eo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sertit_utils.eo.geo_utils.corresponding_utm_projection" href="#sertit_utils.eo.geo_utils.corresponding_utm_projection">corresponding_utm_projection</a></code></li>
<li><code><a title="sertit_utils.eo.geo_utils.from_bounds_to_polygon" href="#sertit_utils.eo.geo_utils.from_bounds_to_polygon">from_bounds_to_polygon</a></code></li>
<li><code><a title="sertit_utils.eo.geo_utils.from_polygon_to_bounds" href="#sertit_utils.eo.geo_utils.from_polygon_to_bounds">from_polygon_to_bounds</a></code></li>
<li><code><a title="sertit_utils.eo.geo_utils.get_aoi_wkt" href="#sertit_utils.eo.geo_utils.get_aoi_wkt">get_aoi_wkt</a></code></li>
<li><code><a title="sertit_utils.eo.geo_utils.get_geodf" href="#sertit_utils.eo.geo_utils.get_geodf">get_geodf</a></code></li>
<li><code><a title="sertit_utils.eo.geo_utils.set_kml_driver" href="#sertit_utils.eo.geo_utils.set_kml_driver">set_kml_driver</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>